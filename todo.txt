
* fix ym7101 to better handle V/H interrupts (right now it sets and then the next step will clear, but it'd be nice if it could 'edge trigger')

* could have a remapper device, which takes a big swath of addresses in and maps them to another set of addresses (for Mac VIA generic to bus-hookup-in-mac adapter)

* sort out how inputing keys will work
* separate the debugger out of m68k, use on_debug or something to print out debug info
* make devices nameable, using a hashmap to store them

* how can you do devices that change their address map during operation, like mac which puts rom at 0 and ram at 600000 temporarily 
* i need a better way of handling disperate reads/writes to I/O spaces, rather than having multiple devices or having a massive chunk of address space allocated, continuously
* should you modify Addressable to also take the absolute address as input?  I'm thinking of how the same device could be mapped to multiple addresses in memory instead
  of taking up a whole range of addresses
* could you use a generic sharable signal thing for sharing data, such as the VIA in mac128 where a single output bit determines the video mode (which would be a separate device)
  So both could share the same Signal, one setting it and the other reading it, but how would you actually configure/build that?


We Need:
  * devices that change address mapping during operation
  * device that can be mapped to multiple separated locations while sharing data
  * subdevices that can share data (eg. signal from one to another (mac128 via outputs), or being a subdevice with a special trait (joystick))



* implement a Z80
* maybe see about a Mac 128k or something

* add instruction timing to M68k
* YM7101 timing is causing it to be very slow... speeding this up increasing rendering speed a lot, even though the frame shouldn't be drawn that often... not sure what's wrong with the timing
* make the ym7101 set/reset the v_int occurred flag based on the interrupt controller


* you could modify read()/write() in Addressable to return the number of bytes read or written for dynamic bus sizing used by the MC68020+
* should you simulate bus arbitration?



* make tests for each instruction
* check all instructions in the docs

* unimplemented: ABCD, ADDX, BFFFO, BFINS, BKPT, CHK, EXG, ILLEGAL, MOVEfromCCR, MOVEP, RTR, RTD, SBCD, SUBX
* >=MC68020 undecoded & unimplemented: CALLM, CAS, CAS2, CHK2, CMP2, RTM, PACK, TRAPcc, UNPK

* add support for MMU
* add support for FPU
* Coprocessor instructions: cpBcc, cpDBcc, cpGEN, cpScc, cpTRAPcc


* how can you have multple CPUs
* each device that can make a bus request should have a BusPort which is used to access the bus
* can you eventually make the system connections all configurable via a config file?

