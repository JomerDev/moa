
* the way you're doing debugging is so bad, and something's broken with the Z80
* debugger should return a breakpoint error to the frontend, so that the frontend still runs, instead of suspending the current execution
* can you make the debugger workable in the web ui in some way?  So you can have a debug window open while playing the game or something

* I like making address adapters like this (below)
* you could have busport take a closure or something which translates the address, and returns an error that will be passed up if it occurs
  in order to implement the correct behaviour for address exceptions in 68k, transparently

* go through Z80 and see if you can replace functions with From<>/Into

* go through flags on m68k and see if you can fix the remaining ones and/or clean up the implementation

* you could possibly make a Z80MemoryPort type that wraps the BusPort type and which impls Addressable, which can be passed into the decoder
  to auto-insert things like the refresh counter, as well as the record all bus timings whenever any mem access is performed
* should you make Address a newtype and add From impls for each type of numeric, and add utils to wrap address at certain boundaries and such
* should you make a means of storing different kinds of buses?
* should you make buses hide their RcRefCell?
* make functions for creating a processor instance from the cpu type (M68k::from_type()), ie. initialize the busport internally with the correct
  bitwidths, but it would still be possible to initialize the CPU manually to create one that never existed as such


* address repeater on ym2612 doesn't seem to work the same, when it's on the 68000 device.  The Z80 device doesn't have an affect, but maybe it's not being used
* sound doesn't work on a lot of games... is it a problem with the Z80 accessing the YM2612, or the lack of YM timers? or something else?
* make the ym generate audio in sync so the DAC timings can be more accurate
* add stereo output to ym2612
* you need to scale the output sample to be +/- 1.0 instead of 0-1.0
* fix ym2612 sound generation (no drums/bass, no LFO, etc)

* what if, to allow a device to have multiple steppable functions, you pass the system in, or otherwise provide some mechanism for
  each device to create sub devices which are scheduled independently
* should it be possible to reschedule multiple events at different intervals to reduce the times a given step function is called?  Some have
  multiple clocks, or multiple things at different clocks, and making them each an event would mean they could be smaller and faster, but at
  the cost of having more events on the queue when re-scheduling.  There needs to be a mechanism to avoid the event queue ballooning due to
  an error
* can you somehow make devices have two step functions for running things at different times? (I'm thinking ym2612 audio gen vs timers)

* for some unknown reason, the js-based updater works much better than the rust based one, but the rust based one just goes back to
  a fixed time per loop instead of trying to speed up
* can you refactor the update timeout to put it in rust?  Would that make it faster? (the tricky part is the closure)

* make Signal directional, by making SignalDriver and SignalInput or SignalReceiver
* clean up pixels frontend

* modify cpal code to skip audio until caught up
* AudioFrame (and possibly the mixer and source) should be moved to the core, it should probably have the sample rate
* split AudioOutput into a sender and receiver
* can you eliminate the source-to-mixer queues?


* should you rename devices.rs traits.rs?
* the interrupt controller stuff is really not good.  It should be more like busport, and connected to a device at startup (eg. create
  interrupt controller, then create objects that use that controller and pass in values, maybe an option so that the controller doesn't
  have to be hooked up, meaning hardware interrupts would not be used.
* I'm kind of thinking of packaging things a bit differently, like using a tuple struct for the rc refcell
  transmutable abstraction, so that you can avoid the need for explicit borrows

* add rust runtime checks for math to look for overflow errors
* I think the overflowing add and subs return the original number and not the overflowed result.  I might have already checked that
  in the m68k impl but I should check again
* double check the functioning of the banked areas and register settings for Z80 coprocessor
* test the Z80 more, add tests like jsmoo's
* add opentelemetry if it can be wasm compatible, or some kind of timing for giving an average framerate
* improve performance

* can you make the frontend more adaptive to the input that the devices are using
* maybe I should make ClockDuration use picos as the base instead, and use u64 since that gives like 212 days or something instead of 5h
  and should prevent split nanoseconds which is the main concern
* make the keys easier to config...

* add doc strings everywhere
* get rustfmt, rustdoc, and clippy working in some kind of semi-automatic fashion


* add ability to serialize/deserialize state into something, so it can be restored... (maybe not worth it though)


* can you make the debugger more accessible, so a web interface could access the data and display it, in light of the fact that println isn't available in wasm

Web Assembly:
    * can you make the web interface nicer with like... a picture of a genesis or something

* make it possible to compile without audio support (minifb frontend requires it atm)


System/Traits:

    * can you make the connections between things (like memory adapters), be expressed in a way that's more similar to the electrical design?
      like specifying that address pins 10-7 should be ignored/unconnected, pin 11 will connect to "chip select", etc
    * should you add a unique ID to devices, such that they can be indexed, and their step functions can reset the next_run count and run them immediately

    * should you simulate bus arbitration?
    * interrupts could be done in a better way
    * need a better way of handling disparate reads/writes to I/O spaces, rather than having multiple devices or having a massive chunk of address space allocated, continuously
    * should you modify Addressable to also take the absolute address as input?  I'm thinking of how the same device could be mapped to multiple addresses in memory instead
      of taking up a whole range of addresses
    * you could modify read()/write() in Addressable to return the number of bytes read or written for dynamic bus sizing used by the MC68020+


Debugger:

    * i need a way to debug only the cpu and not the coprocessor, but that's tricky without a way to id or compare Transmutables
    * add a way to delete a watcher
    * can you improve how the watcher implementation in the Bus works, instead of setting a flag and then checking it every cycle, pass in the System to Addressable??
    * can you use the breakpoint address parser in other commands?
    * get stack tracing working again, but can you do it with just data?
    * how can you improve the debugger?
    * the command line definitely needs to be fixed so it prints the prompt correctly
    * debugger could maybe even allows arrows left/right for editing, and up/down for history


Genesis/Mega Drive:

    * there is an issue with Mortal Kombat 2 where it will crash randomly at the start of a fight.  The code is actually swapping
      stacks a bunch of times, and at some point, the stack is corrupted or something and it `rts`s to the wrong address...

    * the 68000/Z80 bank switching is probably buggy
    * the H/V counters are not accurate because it seems to count at different speeds in the blanking period (time vs return value numbers don't divide properly)
    * make the ym7101 set/reset the v_int occurred flag based on the interrupt controller
    * add support for the sprite overflow flag (low priority)
    * still possibly a bug with the shadow/highlight colours


Macintosh:

    * issues when booting the rom, attempt to write to rom during the driver init/open phase
    * for the address bus/repeating thing in the mac with the rom and ram, can you make it work for both the 128 and 512


68000:

    * unimplemented:  BFFFO, BFINS, NBCD, RTD
    * >=MC68020 undecoded & unimplemented: BKPT, CALLM, CAS, CAS2, CHK2, CMP2, RTM, PACK, TRAPcc, UNPK

    * add support for MMU
    * add support for FPU
    * Coprocessor instructions: cpBcc, cpDBcc, cpGEN, cpScc, cpTRAPcc


Z80:

    * add instruction timings to Z80
    * unimplemented: CPD, CPDR, CPI, CPIR, DAA, IND, INDR, INI, INIR, INic, INx, OTDR, OTIR, OUTD, OUTI, OUTic, OUTx, RETI, RETN, RLD, RRD

Synth:

    * add mouse support to synth app

* can you eventually make the system connections all configurable via a config file?

