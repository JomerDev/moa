
* modify the interrupt handling to make the interrupted device acknowledge the interrupt, probably via the interrupt controller somehow.  It might need to be async
  such that the cpu tells the int_controller it's acknowledged, and then the interrupting device can check the interrupt controller if it needs to see the ack

* each device that can make a bus request should have a BusPort which is used to access the bus.  Not sure how it'll be created or passed to the device, since
  the offset should be set by the builder or system, and the mask and data size should be sent by the CPU (although I suppose some systems could hook it up differently)
* what about even vs odd accesses?  If you access a byte, should the bus port possible turn it into a word access, and return only the byte portion?
  this would be more accurate for the 68000 which doesn't have an A0 address pin
* there is clearly an issue with the ROM writing 4 bytes to the data port when the autoincrement is only 2.  This might be an issue with the fact that the CPU
  is making full long word requests even though the 68000 shouldn't be able to (a long word would be 2 word accesses)


* make devices nameable, using a hashmap to store them
* can you eventually make the system connections all configurable via a config file?
* you could modify read/write to return the number of bytes read or written for dynamic bus sizing used by the MC68020+


* make tests for each instruction

* unimplemented: ABCD, ADDX, BFFFO, BFINS, BKPT, CHK, EXG, ILLEGAL, MOVEfromCCR, MOVEP, RTR, RTD, SBCD, SUBX
* >=MC68020 undecoded & unimplemented: CALLM, CAS, CAS2, CHK2, CMP2, RTM, PACK, TRAPcc, UNPK

* add support for MMU
* add support for FPU
* Coprocessor instructions: cpBcc, cpDBcc, cpGEN, cpScc, cpTRAPcc


* how can you have multple CPUs
* should you simulate bus arbitration?


* check all instructions in the docs

 
